---
title: "In-class Exercise 06"
---

Loading libraries

```{r}
pacman::p_load(sf, tidyverse, spdep, sp, tmap, ClustGeo, ggpubr, cluster, factoextra, NbClust, heatmaply, corrplot, psych, GGally)
```

Importing data into environment

```{r}
ict <- read_csv("data/aspatial/Shan-ICT.csv")
shan_sf <- st_read(dsn = "data/geospatial", layer = "myanmar_township_boundaries") |>
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) |>
  select(c(2:7))

```

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

Plotting

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

Joining the data

```{r}
shan_sf <- shan_sf |> left_join(ict_derived, by = "TS_PCODE")
```

Correlation plot

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

-   Rounded = less correlation

-   Narrower = higher correlation

-   Computer and internet is highly correlated

Extracting clustering variables and changing it into dataframe

```{r}
cluster_vars <- shan_sf |>
  st_set_geometry(NULL) |>
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

Changing row names by index to town name

```{r}
row.names(cluster_vars) <- cluster_vars$TS.x
head(cluster_vars, 10)
```

Dropping the town name that is no longer needed

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

Data standardisation

1.  Min-Max standardisation

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

2.  Z score standardisation

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

freeze = TRUE (prevent file from rendering

Deriving proximity matrix

*dist()* supports six distance proximity calculations, they are: **euclidean, maximum, manhattan, canberra, binary and minkowski**. The default is *euclidean* proximity matrix.

manhattan = city-block distance

minkowski = Chebychev distance

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
proxmat
```

deriving hierarchical clustering

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

Plotting dendrogram

```{r}
plot(hclust_ward, cex = 0.6)
```

Selecting optimum clustering algorithm

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

-   Ward is the best

Determining optimal clusters

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
```

Producing dendogram with border around selected clusters

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

Deriving cluster model

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

Joining cluster model with sf data

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

Plotting choropleth map of clusters

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

```{r}
shan_sp <- as_Spatial(shan_sf)
```

Computing neighbour list

```{r}
shan.nb <- poly2nb(shan_sp)
summary(shan.nb)
```

```{r}
plot(shan_sp, 
     border=grey(.5))
plot(shan.nb, 
     coordinates(shan_sp), 
     col="blue", 
     add=TRUE)
```
