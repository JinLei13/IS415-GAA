---
title: "Hands-on Exercise 04: Spatial Weights and Applications "
---

## Loading packages that will be used for this hands-on exercise

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## Importing the datasets that will be used for this hands-on exercise

```{r}
hunan <- st_read(dsn = "data/geospatial", layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

-   hunan consists of 88 multi-polygon features with 7 fields

## Performing relational join on the two datasets 

```{r}
hunan <- left_join(hunan,hunan2012) |> 
  select(1:4, 7, 15)
```

## Creating a basemap and choropleth map showing the distribution of GDPPC 2012 

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)
gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## Computing Contiguity Spatial Weights 

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

## Obtaining the neighbors for the first polygon in the object wm_q

```{r}
wm_q[[1]]
```

-   The first polygon has five neighbors and they are polygon 2, 3, 4, 57 and 85

### Retrieving the county name of polygon that has corresponding ID of 1

```{r}
hunan$County[1]
```

### obtaining county names of the five neighbors of the first polygon 

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

### Retrieving the GDPPC of these five counties 

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

### Displaying the complete weight matrix 

```{r}
str(wm_q)
```

## Creating (ROOK) contiguity based neighbors 

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

-   Summary reports shows that there are 88 area units in Hunan

-   The most connected area unit has 10 neighbors

-   There are two area units that are least connected with one neighbor

## Visualising contiguity weights 

### Obtaining the longitude values 

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

### Obtaining the latitude values 

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

### Combining longitude and latitude into a single object

```{r}
coords <- cbind(longitude, latitude)
```

checking the first few observations to see if things are formatted correctly

```{r}
head(coords, n = 10 )
```

### Plotting Queen contiguity based neighbors map 

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

### Plotting ROOK contiguity based neighbors map 

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### Plotting muti-map of Queen and ROOK contiguity based neighbors maps 

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## Computing distance based neighbors 

### Determining the cut-off distance 

1.  Using knearneigh() function to return a matrix with the indices of points belonging to the set of the k nearest neighbors of each other.
2.  Using knn2nb(0 function to convert the knn object returned by knearneigh() function into a neighbors list of class np with a list of integer vectors containing neighbor region number IDs
3.  Using nbdists() function to return the length of neighbors relationship edges
4.  Using unlist() function to remove the list structure of the returned object

```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

-   The summary reports shows that the largest five nearest neighbor distance is 61.79 Kilometers

### Computing fixed distance weight matrix 

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

displaying content of the fixed distance weight matrix

```{r}
str(wm_d62)
```

-   Alternatively, we can also use table() and card() functions to display the structure of the weight matrix

```{r}
table(hunan$County, card(wm_d62))
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
table(n_comp$comp.id)
```

### Plotting fixed distance weight matrix 

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

-   Red lines show the links of 1st nearest neighbors

-   Black lines show the links of neighbors within the cut-off distance of 62km

### Creating multi-plots of 1st nearest neighbors and distance link within the cut-off distance of 62km

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)
```

## Computing adaptive distance weight matrix 

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
str(knn6)
```

### Plotting adaptive distance based neighbors 

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## Computing spatial weight matrix based on Inversed Distance method 

1.  Computing distances between areas by using nbdists() function

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

### Assigning weights to each neighboring polygon 

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

### Displaying the weights of the first polygon's eight neighbors

```{r}
rswm_q$weights[10]
```

### Deriving a row standardised distance weight matrix 

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
rswm_ids$weights[1]
summary(unlist(rswm_ids$weights))
```

### Computing the average neighbor GDPPC value for each polygon

-   These values are often referred to as spatially lagged values

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

### Retrieving the GDPPC of these five counties 

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

### Appending the spatially lag GDPPC values onto hunan sf dataframe 

```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
head(hunan, n = 10)
```

### Plotting of choropleth map of both the GDPPC and spatial lag GDPPC for comparison 

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

### Applying a function that will Assign a value of 1 per each neighbor 

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

### Computing a lag variable from our weight and GDPPC

```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
lag_sum
```

### Appending the lag_sum GDPPC field into hunan sf dataframe 

```{r}
hunan <- left_join(hunan, lag.res)
```

### Plotting of choropleth map of both GDPPC and spatial lag sum GDPPC for comparison 

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

### Appending diagonal element to the neighbor list 

```{r}
wm_qs <- include.self(wm_q)
wm_qs[[1]]
wm_qs <- nb2listw(wm_qs)
wm_qs
```

### Creating the lag variable from our weight structure and GDPPC variable 

```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```

### Converting the lag variable listw object into a dataframe 

```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

### Appeding the value of lag GDPPC and spatial window average 

```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
hunan |>
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") |>
  kable()
```

### Plotting mutiple choropleth maps of lag_gdppc and w_ave_gdppc 

```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```

### Adding diagonal elements to the neighbor list 

```{r}
wm_qs <- include.self(wm_q)
wm_qs
```

### Assigning binary weights to the neighbor structure that includes the diagonal element

```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

### Computing the lag variable 

```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```

### Converting the lag variable listw object into a dataframe 

```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

### Appending w_sum GDPPC values onto the hunan sf dataframe 

```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
hunan |>
  select("County", "lag_sum GDPPC", "w_sum GDPPC") |> 
  kable()
```

### Plotting of multiple choropleth maps to compare the lag_sum GDPPC and w_sum_gdppc maps 

```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```
